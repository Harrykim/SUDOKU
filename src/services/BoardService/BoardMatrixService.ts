import { cloneDeep, uniq, sum, shuffle } from 'lodash'

import { BoardDifficulty, BoardDifficultyToNumberOfDefaultCellsMapping, DEFAULT_BOARD_SECTION_SIZE } from '../../models/Board'
import { BoardMatrix, CellInBoardMatrix, IBoardMatrixValidation } from '../../models/BoardMatrix'
import { ArgumentError } from '../../models/Error'

import { BoardRepository } from '../../repositories/BoardRepository'
import { generateRandomNumber } from '../../utilities/generateRandomNumber'
import { sumTo } from '../../utilities/sumTo'

interface IMatrixesToValidate {
  rowMatrixToValidate: BoardMatrix
  columnMatrixToValidate: BoardMatrix
  sectionMatrixToValidate: BoardMatrix
}

class BoardMatrixService {

  /**
   * @param size board size
   * @param difficulty difficulty of board
   * @returns Returns a generated board according to the difficulty
   */
  generateBoard(size: number, difficulty: BoardDifficulty): BoardMatrix {
    const emptyBoard = this.generateEmptyBoard(size)
    const completedBoard = this.solveBoard(emptyBoard)
    if (!completedBoard) { this.generateBoard(size, difficulty) }

    const difficultyAdjustedBoard = this.adjustBoardDifficulty(completedBoard as BoardMatrix, difficulty)
    return difficultyAdjustedBoard
  }

  /**
   * @param size board size
   * @returns Returns an empty board
   */
  generateEmptyBoard(size: number, fillNull: boolean = true): BoardMatrix {
    const board = []
    for (let i = 0; i < size; i++) {
      board.push([])

      if (fillNull) {
        for (let k = 0; k < size; k++) {
          board[i][k] = null
        }
      }
    }

    return board
  }

  /**
   * @param board BoardMatrix to validate duplication
   * @returns Returns a list of indexes of invalid rows, columns and sections
   */
  validateDuplication(board: BoardMatrix): IBoardMatrixValidation {
    const {rowMatrixToValidate, columnMatrixToValidate, sectionMatrixToValidate} = this.getMatrixesToValidate(board)

    const invalidRowIndexes: number[] = []
    const invalidColumnIndexes: number[] = []
    const invalidSectionIndexes: number[] = []
    rowMatrixToValidate.forEach((row, i) => {
      if (row.length !== uniq(row).length) {
        invalidRowIndexes.push(i)
      }
    })
    columnMatrixToValidate.forEach((row, i) => {
      if (row.length !== uniq(row).length) {
        invalidColumnIndexes.push(i)
      }
    })
    sectionMatrixToValidate.forEach((row, i) => {
      if (row.length !== uniq(row).length) {
        invalidSectionIndexes.push(i)
      }
    })

    return {
      rows: invalidRowIndexes,
      columns: invalidColumnIndexes,
      sections: invalidSectionIndexes
    }
  }

  /**
   * Description:
   *  - Given each matrix, sum of unique elements should equal to sumTo(boardSize) to qualify completion
   *
   * @param board BoardMatrix to validate completion
   * @returns Returns true if board can be completed
   */
  canComplete(board: BoardMatrix): boolean {
    const {rowMatrixToValidate, columnMatrixToValidate, sectionMatrixToValidate} = this.getMatrixesToValidate(board)
    const allMatrixesToValidate = [...rowMatrixToValidate, ...columnMatrixToValidate, ...sectionMatrixToValidate]
    return allMatrixesToValidate.every((matrix) => sum(uniq(matrix)) === sumTo(board.length))
  }

  /**
   * Description:
   *  - Given the row and column, get an index of the section.
   *  - It is calculated by sectionColumnIndex * DEFAULT_BOARD_SECTION_SIZE + sectionRowIndex
   *
   * @param row x-coordinate
   * @param column y-coordinate
   * @returns Returns an index of the section
   */
  getSectionIndex(row: number, column: number): number {
    const sectionRowIndex = Math.floor(row / DEFAULT_BOARD_SECTION_SIZE)
    const sectionColumnIndex = Math.floor(column / DEFAULT_BOARD_SECTION_SIZE)
    return sectionColumnIndex * DEFAULT_BOARD_SECTION_SIZE + sectionRowIndex

  }

  /**
   * Description:
   *  - provide a boardMatrix with only default values. The rest will be auto-generated by the method
   *
   * @param board board matrix to complete
   * @returns Returns a solved board matrix
   */
  solveBoard(board: BoardMatrix) {
    const {row: nextRow, column: nextColumn} = this.nextEmptyCell(board)
    if (nextRow === undefined && nextColumn === undefined) { return board }

    const valuesToTry: number[] = shuffle(Array.from({length: board.length}, (v, i) => i + 1))
    for (let value of valuesToTry) {
      if (this.isSafeToFill(board, nextRow, nextColumn, value)) {
        board[nextColumn][nextRow] = value

        if (this.solveBoard(board)) {
          return board
        } else {
          board[nextColumn][nextRow] = null
        }

      }
    }
    return false

  }


  nextEmptyCell(board: BoardMatrix): {row: number, column: number} {
    for (let i = 0; i < board.length; i++) {
      for (let k = 0; k < board.length; k++) {
        if (!board[i][k]) {
          return {row: k, column: i}
        }
      }
    }

    return {row: undefined, column: undefined}
  }

  /**
   * Description:
   *  - With a given board, generate matrixes to be used to validate
   *
   * @param board board matrix
   * @returns Returns rows, columns and sections matrixes to validate
   */
  private getMatrixesToValidate(board: BoardMatrix): IMatrixesToValidate {
    const rowMatrixToValidate = this.generateEmptyBoard(board.length, false)
    const columnMatrixToValidate = this.generateEmptyBoard(board.length, false)
    const sectionMatrixToValidate = this.generateEmptyBoard(board.length, false)

    for (let i = 0; i < board.length; i++) {
      for (let k = 0; k < board.length; k++) {
        const value = board[i][k]
        if (value) {
          const sectionIndex = this.getSectionIndex(k, i)
          rowMatrixToValidate[i].push(value)
          columnMatrixToValidate[k].push(value)
          sectionMatrixToValidate[sectionIndex].push(value)
        }
      }
    }

    return {
      rowMatrixToValidate,
      columnMatrixToValidate,
      sectionMatrixToValidate
    }
  }

  /**
   * Description:
   *  - With a given board, remove some values to adjust difficulty
   *
   * @param board board matrix
   * @param difficulty board difficulty
   * @returns Returns rows, columns and sections matrixes to validate
   */
  private adjustBoardDifficulty(board: BoardMatrix, difficulty: BoardDifficulty): BoardMatrix {
    const boardToUse = cloneDeep(board)
    const numberOfDefaultCells = this.convertDifficultyToNumberOfDefaultCells(difficulty)
    const boardSize = boardToUse.length
    let defaultCellCounter: number = 0

    // remove values until {boardSize * boardSize - numberOfDefaultCells} cells are filled
    const numberOfCellsToRemove = boardSize * boardSize - numberOfDefaultCells
    while (defaultCellCounter < numberOfDefaultCells) {
      const col = generateRandomNumber(boardSize)
      const row = generateRandomNumber(boardSize)
      const newCellValue = generateRandomNumber(boardSize + 1, 1)
      if (newCellValue > boardSize) {
        throw new ArgumentError('newCellValue', `Cell value cannot exceed ${boardSize}`)
      }

      // if board already does not have a value for the position, continue
      if (!boardToUse[col][row]) {
        continue
      }

      boardToUse[col][row] = null
      defaultCellCounter++
    }
    return boardToUse
  }

  /**
   * @param board
   * @param row x-coordinate
   * @param col y-coordinate
   * @param value new value
   * @returns Returns true if the value can be added to the board
   */
  private isSafeToFill(board: BoardMatrix, row: number, col: number, value: number): boolean {
    if (!this.isRowValid(board, col, value)) { return false }
    if (!this.isColumnValid(board, row, value)) { return false }
    if (!this.isSectionValid(board, row, col, value)) { return false }
    return true
  }

  /**
   * @param board
   * @param col y-coordinate
   * @param value new value
   * @returns Returns true if the value can be added to the row
   */
  private isRowValid(board: BoardMatrix, col: number, value: number): boolean {
    const matrixRow = board[col]
    return !matrixRow.includes(value)
  }

  /**
   * @param board
   * @param row x-coordinate
   * @param value new value
   * @returns Returns true if the value can be added to the column
   */
  private isColumnValid(board: BoardMatrix, row: number, value: number): boolean {
    const matrixColumn: CellInBoardMatrix[] = []
    for (let i = 0; i < board.length; i++) {
      matrixColumn.push(board[i][row])
    }
    return !matrixColumn.includes(value)
  }

  /**
   * @param board
   * @param row x-coordinate
   * @param col y-coordinate
   * @param value new value
   * @returns Returns true if the value can be added to the section
   */
  private isSectionValid(board: BoardMatrix, row: number, col: number, value: number): boolean {
    const rowSec = Math.floor(row / DEFAULT_BOARD_SECTION_SIZE)
    const columnSec = Math.floor(col / DEFAULT_BOARD_SECTION_SIZE)

    const rowLeftBoundary = DEFAULT_BOARD_SECTION_SIZE * rowSec
    const rowRightBoundary = DEFAULT_BOARD_SECTION_SIZE * (rowSec + 1)
    const columnTopBoundary = DEFAULT_BOARD_SECTION_SIZE * columnSec
    const columnBottomBoundary = DEFAULT_BOARD_SECTION_SIZE * (columnSec + 1)

    let matrixSection: CellInBoardMatrix[] = []
    for (let i = columnTopBoundary; i < columnBottomBoundary; i++) {
      for (let k = rowLeftBoundary; k < rowRightBoundary; k++) {
        matrixSection.push(board[i][k])
      }
    }

    return !matrixSection.includes(value)
  }

  /**
   * @param difficulty difficulty of board
   * @returns Returns number of default cells to set
   */
  private convertDifficultyToNumberOfDefaultCells(difficulty: BoardDifficulty): BoardDifficultyToNumberOfDefaultCellsMapping {
    switch (difficulty) {
      case BoardDifficulty.HARD:
        return BoardDifficultyToNumberOfDefaultCellsMapping.HARD
      case BoardDifficulty.MEDIUM:
        return BoardDifficultyToNumberOfDefaultCellsMapping.MEDIUM
      case BoardDifficulty.EASY:
      default:
        return BoardDifficultyToNumberOfDefaultCellsMapping.EASY
    }
  }
}

const boardMatrixServiceInstance = new BoardMatrixService()
export {boardMatrixServiceInstance as BoardMatrixService}
